---
title: "A Unifying Open Policy Analysis for Deworming"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
    code_folding: hide
    code_download: true
    collapsed: yes
    keep_md: yes
    number_sections: yes
    smooth_scroll: no
    toc: yes
    toc_depth: 3
    toc_float: yes
  pdf_document: default
  word_document: default
editor_options:
  chunk_output_type: console
pdf_document:
  extra_dependencies: ["xcolor"]
---
\def\blue{\color{blue}}
\def\red{\color{red}}




```{r setup, include=FALSE}
# Loading required libraries
list.of.packages <- c("tidyverse", "haven", "here", "kableExtra", "readxl")

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, repos= "http://cran.cnr.berkeley.edu/")

lapply(list.of.packages, library, character.only = TRUE)

knitr::opts_knit$set(root.dir = here())
knitr::opts_chunk$set(echo = TRUE)

print_code <- TRUE


colorize = function(x, color){
  if (knitr::is_latex_output()) {
    sprintf("\\textcolor{%s}(%s)", color, x)
  } else if (knitr::is_html_output()) {
    sprintf("<font color='%s'>%s</font>", color, x)
  } else x
}
```



```{r notes}
################
#####  Notes:
################
### Source ---------->  Input ---------->  Model ---------->  Policy Estimates (output)
###  (_so)              (_in)              (_mo)                (_pe)
### values            functions          functions              values
###                   & values           & values             
# - call_sources_f- tax_elasticity_in_f  - tax_revenue_mo_f     - ten_year_revenue_pe
# - policy_f      - est_billionares_in_f - total_rev_mo_f       - ten_year_top_tax_pe
#                                        - ten_years_mo_f       - total_rev_pe
### arguments in functions should used "_var" and functions should "_f"


# DESCRIBE FUNCTIONS STRUCTURE
# - inputs: list
# - outputs: list
#### function:  
#sample_function_f <- function(){
##########################################
##########################################  
#
# here goes the content
#
##########################################
##########################################  
#    return( )                                  # A list with all (most?) the elements
#}                                              # generated inside the function
#invisible( list2env(sample_function_f(),.GlobalEnv) )
#
```


```{r sources, eval = TRUE, echo=print_code, message=FALSE, warning=FALSE}
chunk_params <- function(){
###############################################################################
###############################################################################  

    #############
    ##### Data  
    #############
    gov_bonds_so <- 	0.1185	     #Kenyan interest on sovereign debt - Central Bank of Kenya
    inflation_so <-  0.02          #Kenyan inflation rate - World Bank Development Indicators
    wage_ag_so <- 	11.84	         #Mean hourly wage rate (KSH) - Suri 2011
    wage_ww_so <- 	14.5850933     #Control group hourly wage, ww (cond >=10 hrs per week) - Table 4, Panel B
    profits_se_so <- 1766          #Control group monthly self-employed profits - Table 4, Panel A  FIX: MOST REFERENCES FROM TABLE 4 ARE TABLE 3
    hours_se_cond_so <- 38.1       #Control group weekly self-employed hours, conditional on hrs >0 - Table D13, Panel D
    hours_ag_so <- 8.3             #Control group hrs per week, agriculture - Table 4, Panel D
    hours_ww_so <- 6.9             #Control group hrs per week, working for wages - Table 4, Panel B
    hours_se_so <- 3.3             #Control group hrs per week, self-employment - Table 4, Panel A
    ex_rate_so <- 85               #Exchange Rate - Central Bank of Kenya
    growth_rate_so <- 1.52/100     #Per-capita GDP growth, 2002-2011 (accessed 1/29/13) -	World Bank - see notes
    coverage_so  <- 0.681333333    # (R) Fraction of treated primary school students within 6 km - from W@W - see note
    tax_so <- 0.16575              #ADD INFO!
    unit_cost_local_so <- 43.66    #Deworm the World
    years_of_treat_so <- 2.41      #Additional Years of Treatment - Table 1, Panel A

    # costs data
    df_costs_so <- read_excel("rawdata/data/DtW Cost per Child Data.xlsx",
                           sheet = "DtW Costs")
    # crosswalk data on region and country
    df_costs_cw_so <- read_excel("rawdata/data/DtW Cost per Child Data.xlsx",
                           sheet = "state_country")

    # data on number of treated children
    df_counts_so <- read_excel("rawdata/data/DtW Cost per Child Data.xlsx",
                           sheet = "DtW Treatment #s")

    #############
    ##### Research
    #############    
    lambda1_so <- c(3.49, 0)            #Hrs per week increase for men and women CONFIRM
    lambda2_so <- 10.2                  #Externality effect (proportional) - Table 3, Panel B
    lambda1_new_so <- c(87, 83, 81)     # Direct treatment effect on earnings. From tables generated by Michelle on 10/4/1
    lambda1_new_sd_so <- c(43, 83, 172)  # ADD SOURCE

    q_full_so <- 0.75              #Take up rates with full subsidy. From Miguel and Kremmer (2007)
    q_zero_so <- 0                 #Take up rates with zero subsidy. From Miguel and Kremmer (2007)
    delta_ed_so <- c(-0.00176350949079451, 0.00696052250263997, 0.0258570306763183,     # (Delta E) Additional direct seconday schooling increase (from Joan)
                        0.0239963665555466, 0.027301406306074, 0.0234125454594173,
                       0.0279278879439199, 0.00647044449446303, 0.00835739437790601)                                     
    delta_ed_so <- cbind(delta_ed_so, 1999:2007)
    delta_ed_ext_so <- c(-0.0110126908021048,	0.0140448546741008,	-0.0034636291545585,  #Additional externality secondary schooling increase (from Joan)
                           0.0112940214439477,	0.0571608179771775,	-0.0560546793186931,
                           0.0558284756343451,	0.1546264843901160,	0.0055961489945619)
    delta_ed_ext_so <- cbind(delta_ed_ext_so, 1999:2007)    
    include_ext_so <- TRUE
    alpha_0_so <- 1 # 0.92
    alpha_r_so <- 1 # 0.3

    #############
    ##### Guess work   
    #############
    periods_so <- 50               #Total number of periods to forecast wages
    time_to_jm_so <- 10            #Time from intial period until individual join the labor force
    coef_exp_so <- c(0, 0)         #Years of experience coefficients (1-linear, 2-cuadratic)	- see notes
    teach_sal_so <- 5041           #Yearly secondary schooling compensation	5041 - from ROI materials
    teach_ben_so <- 217.47         #Yearly secondary schooling teacher benefits	217.47
    n_students_so <- 45            #Average pupils per teacher	45

    staff_time_so <- 0.3           #Added Deworming costs due to goverment staff time
    return( sapply( ls(pattern= "_so\\b"), function(x) get(x)) )
    
###############################################################################
###############################################################################  

}
invisible( list2env(chunk_params(),.GlobalEnv) )

#############
##### Notes:
#############
### Source ---->  Input ----> Model ----> Policy Estimates (output)
###  (_so)        (_in)       (_mo)        (_pe)
### values      functions   functions      values
###             & values    & values
### arguments in functions should used "_var" and functions should "_f"

#invisible( list2env(chunk_name(),.GlobalEnv) )

# on growth_rate_so: (http://data.worldbank.org/indicator/NY.GDP.PCAP.KD/), see calculation on "Kenya GDP per capita" tab. In W@W this equals 1.52%. ISSUE: This growth number should be updated to be 2002-2014, I think.
# on coef_exp_so: 1998/1999 Kenyan labor force survey; regression of earnings on age, age^2, female dummy, indicators for attained primary/secondary/beyond, and province dummies. Estimate used in W@W: (0.1019575, -0.0010413). ISSUE: For now assume no further life cycle adjustment beyond KLPS-3 (likely a conservative assumption).
# coverage_so: Overall Saturation (0.511) / 0.75 - not reported in table, average of T & C

```



# Key policy estimates for policy makers  

The key policy estimate consists of a cost effectiveness analysis that compares the present
value of benefits and costs. The benefits quantified here are the effects on wages an the
costs are those of delivering the deworming treatment.  


```{r final-output, echo=print_code}

```


The benefits will account for the direct effects of deworming and plus the indirect effects of deworming due to smaller pool of sick people in the community (herd inmunity). Effects are computed as a change in the earning profile of the population.


# Methodology

This analaysis contains elements from GiveWell's cost effectiveness analaysis (see [here](https://docs.google.com/spreadsheets/d/1McptF0GVGv-QBlhWx_IoNVstWvt1z-RwVSu16ciypgs/edit#gid=1537947274), an editable version can be found [here](https://docs.google.com/spreadsheets/d/1rL8NPB8xnxqs1pr_MMEA0j27sAqEuAluwGSML7pREzk/edit#gid=1537947274))  and the cost benefit analysis described in [Baird et al., 2016](https://academic.oup.com/qje/article/131/4/1637/2468871).  

## Main Equation (the model)

The key result for policy makers is defined as the cost effectivness ratio (cell [`Deworming!B32`](https://docs.google.com/spreadsheets/d/1rL8NPB8xnxqs1pr_MMEA0j27sAqEuAluwGSML7pREzk/edit#gid=472531943&range=B32)).

\begin{equation}
CEA_{deworming} = \frac{B (1 + \blue{F_{0}})}{C}
\label{eq:1}
\tag{1}
\end{equation}

 - $C$ is the costs per person dewormed (`F2, 4,B23` --> [`F1, 2, H16`](https://docs.google.com/spreadsheets/d/1hmijmJBeCJAKI1dT8n5iOLAAxfzWrKYJM_KfouFYI2w/edit#gid=1891183342&range=H16)).     
 - $B$ is the benefits per person dewormed (`F2, 4,B22`).
 - $\blue{F_{0}}$ is a factor to account for leverage/fudging [not reviewed in this excercise] ([`F2, 6, D259`](https://docs.google.com/spreadsheets/d/1rL8NPB8xnxqs1pr_MMEA0j27sAqEuAluwGSML7pREzk/edit#gid=1611790402&range=D259))


Also this quantity could be expressed in relative terms to the benchmark of cash transfers (cell [`Results!B9`](https://docs.google.com/spreadsheets/d/1rL8NPB8xnxqs1pr_MMEA0j27sAqEuAluwGSML7pREzk/edit#gid=1034883018&range=B9)):

\begin{equation}
RCEA = \frac{CEA_{deworming}}{CEA_{cash}}
\end{equation}


Also, we can compute the NPV as presented in Baird et al 2016  
\begin{equation}
NPV = B - C
\end{equation}



```{r eq_1, echo=print_code}
# - inputs: total per capita benefits, total per capita costs, fudging factor
# - outputs: Cost-effectiveness ratio & ratio to cash CEA
chunk_policy_est <- function(){
###############################################################################
###############################################################################  

    CEA_pe <- function(benefits_var = 1, fudging_var = 0,
                       costs_var = 1) {
      ( benefits_var * ( 1 + fudging_var ) ) / costs_var
    }
    RCEA_pe <- function(CEA_var = 1, CEA_cash_var = 1) CEA_var / CEA_cash_var

    NPV_pe <- function(benefits_var = 1, costs_var = 1){
        benefits_var - costs_var
    }

###############################################################################
###############################################################################  
    return(list("CEA_pe" = CEA_pe,
                "RCEA_pe" = RCEA_pe,
                "NPV_pe" = NPV_pe))
}
invisible( list2env(chunk_policy_est(),.GlobalEnv) )
```

## Sub-components:

We begin by describing the underlying analysis behind the costs. Through this excercise we use the following notation the letters $F, P, Q$ denote components
in percentages, monetary units (US dollars and local currency) and quantities respectively. Each new element will be tracked using a sub-index, and supra-indecis will be
used to track groups, like geographies, time, and other catergories. For example $Q^{i}_{2}$ represents the second quantity described in this analysis (total adjusted number childred dewormed per year) in location $i$. At the end of each description we will show in parenthesis the original location of the parameter in GiveWell's spreadsheets (using the notation `file, sheet number, cell`[^1]). When a parameter in an equation does not depend on any subsequent component, it is highlighted in bold.

### Costs ("$C$")

\begin{equation}
C = \sum_{i \in Countries } \omega_{i} c_{i}
\label{eq:2}
\tag{2}
\end{equation}

GiveWell estimates the cost per child dewormed in geographies where Evidence Action provides technical assistance.These costs include Evidence Action's technical assistance costs, government expenditure (including estimates of government staff time), and any other partner costs such the cost of drugs donated by WHO.

Costs can vary by geography due to factors of scale, treatment strategies, age of the program, and costs of "doing business."

The final cost is a weighted average of the unit cost across countries.

- $\omega_{i}$: Weight for the weighted average ([`F1, 2, C:G8`](https://docs.google.com/spreadsheets/d/1hmijmJBeCJAKI1dT8n5iOLAAxfzWrKYJM_KfouFYI2w/edit#gid=1891183342&range=C8:G8)).  
- $c_{i}$: Total cost per child, per year in country $i$ (`F1, 2, C:G16`).  

Build $c_i$ as a function of three stakeholders: DtW, other donors, goverment.  
Each stakeholders spends on: line items.    
Incorporate currency.

```{r eq_2, echo=print_code}
# - inputs: nothing
# - outputs: function that computs the weighted sum of country costs
chunk_cost1 <- function(){
###############################################################################
###############################################################################  

    costs1_f <- function(country_w_var = 1, country_cost_var = 1) {
        sum(country_w_var * country_cost_var)
    }

###############################################################################
###############################################################################  
    return(list("costs1_f" = costs1_f))
}


invisible( list2env(chunk_cost1(),.GlobalEnv) )
```



\begin{equation}
\omega_{i} = \frac{N_{i}}{\sum_{j}N_{j}} \\
c_{i} = \frac{C_{i}}{N_{i}} \\
\label{eq:3}
\tag{3}
\end{equation}


\begin{equation}
C_{i} = (1 + \delta_{g})\sum_{k \in payers}C_{i,k} \\
C_{i,k} = \sum_{l \in items}\sum_{m \in regions}C_{i,k,l,m}
\label{eq:4}
\tag{4}
\end{equation}




All costs are in USD.

GW original analysis weights each country to take into account the number of treatments provided as well as the proportion of costs incurred by DtWI in that geography. The analytical foundations for such weights are not clear. Also not clear why should only account for DtW costs.  


- $N_{i}$: Number of treated children in country $i$.  
- $Ex_{i}$: Exchange rate from country $i$ to USD.  
- $k$: Costs distribute across $k$ payers.   
- $l$: Each payers costs come from $l$ items.   


```{r eq_3, echo=print_code, eval=TRUE}
# - inputs: nothing
# - outputs: function that computes the country weights used in the final costs
chunk_cost1_inp <- function(){
###############################################################################
###############################################################################  

    costs1_costs_f <- function(df_costs_var = df_costs_so,
                               df_costs_cw_var = df_costs_cw_so,
                               staff_time_var = staff_time_so){
      # Add country
      df_costs_var <- df_costs_cw_var %>%
        right_join(df_costs_var, by = "Country/State") %>%
        select(-Country.y) %>% rename(Country = Country.x) %>%
        mutate(Country = tolower(Country))

      # values for last year with cost information
      df_costs_last <- df_costs_var %>%
        group_by(Country) %>%
        summarise("last_year" = max(Year)) %>%
        right_join(df_costs_var, by = "Country") %>%
        filter(Year == last_year)    

      # summing across payers and regions (last equation)
      costs_by_item_temp <- df_costs_last %>%
        filter(Payer != "Total") %>%
        group_by(Country, `Program Area`) %>%
        summarise("costs_by_region" = sum(suppressWarnings( as.numeric(Cost) ), na.rm = TRUE))

      #sum across country/state and multiply by delta
      country_cost <- costs_by_item_temp %>%
        group_by(Country) %>%
        summarise("costs_by_country" = sum(costs_by_region) * (1 + staff_time_var))  

      return( list("cost_data" = country_cost) )
    }

    costs1_counts_f <- function(df_counts_var = df_counts_so,
                          df_costs_cw_var = df_costs_cw_so){
      # Add country
      df_counts_var <- df_costs_cw_var %>%
        right_join(df_counts_var, by = "Country/State") %>%
        mutate(Country = tolower(Country))

      # values for last year with cost information
      df_counts_last <- df_counts_var %>%
        group_by(Country) %>%
        summarise("last_year" = max(Year)) %>%
        right_join(df_counts_var, by = "Country") %>%
        filter(Year == last_year)    

      c_counts <- df_counts_last %>%
        group_by(Country, Year) %>%
        summarise("total" = sum(`# dewormed`))

      return( list("counts_data" = c_counts) )
    }

    costs1_ratios_in_f <- function(counts_var = costs1_counts_f()$counts_data,
                                   costs_var = costs1_costs_f()$cost_data){
      # create country weight
      c_weights <- counts_var %>% ungroup() %>%
        mutate(country_w = total / sum(total))

      # Compute the per capita cost for each country
      ratios_data <- costs_var %>%
         left_join(c_weights, by = "Country") %>%
         mutate("per_cap" = costs_by_country / total)

          return( list("ratios_data" = ratios_data) )
      }

###############################################################################
###############################################################################  
    return( list("costs1_costs_f" = costs1_costs_f,
                "costs1_counts_f" = costs1_counts_f,
                "costs1_ratios_in_f" = costs1_ratios_in_f) )
}
invisible( list2env(chunk_cost1_inp(),.GlobalEnv) )
```

#### Data required to compute costs.

$N_{i}, C_{i,k,l}, \delta_{g}$

#### Alternative calculation for costs

\begin{equation}
C =  K \sum_{t=0}^{50} \left( \frac{1}{1 + r}\right)^{t} \Delta \overline{E}_{\gamma t}(S1,S2) + \left( S_{2}Q(S_{2}) - S_{1}Q(S_{1}) \right)
\end{equation}

```{r cost2}
# - inputs:
# - outputs:
chunk_cost2 <- function(){
###############################################################################
###############################################################################  

    cost2_f <- function(periods_var = periods_so, delta_ed_var = delta_ed_final_in,
               interest_r_var = interest, cost_of_schooling_var = cost_per_student_in,
               s1_var = 0, q1_var = 0, s2_var = s2_in, q2_var = q2_in) {
        index_t <- 0:periods_var
        delta_ed_s <- c(0, delta_ed_var, rep(0,41))
        sum( ( 1 / (1 + interest_r_var) )^index_t *
                delta_ed_s * cost_of_schooling_var) +
        (s2_var * q2_var  - s1_var * q1_var)
      }

###############################################################################
###############################################################################  
    return(list("cost2_f" = cost2_f))    # Try to return only functions
}
invisible( list2env(chunk_cost2(),.GlobalEnv) )

##### Execute values of the functions above when needed for the text:  


```


##### $K$ and $\Delta \overline{E}_{\gamma t}(S1,S2)$

$K$ represents the cost per student. This is calculated as the salary of the teacher plus benefits, divided by the average number of students per teacher.

\begin{equation}
K = \frac{\text{teacher salary} + \text{teacher benefits}}{\text{# Students}}
\end{equation}

For $\Delta \overline{E}_{\gamma t}(S1,S2)$ we use a series of estimated effects the additional direct increase in secondary schooling from 1999 to 2007 obtained from [need to define the source "from Joan" in `Assumps&Panel A Calcs!A93`].

This series does not take into account the externality effects. To incorporate it we need another series (same source) that estimates the additional secondary schooling increase due to the externality and add it to the original series.

```{r ed-costs}
# - inputs:
# - outputs:
chunk_edcosts <- function(){
###############################################################################
###############################################################################    

    cost_per_student_f <- function(teach_sal_var = teach_sal_so,
                                    teach_ben_var = teach_ben_so,
                                    n_students_var = n_students_so) {
        (teach_sal_var + teach_ben_var) / n_students_var
    }

    delta_ed_final_f <- function(include_ext_var = include_ext_so, delta_ed_var = delta_ed_so,
                           delta_ed_ext_var = delta_ed_ext_so){
        if (include_ext_var == TRUE){
            delta_ed_final_in <-  delta_ed_ext_var[,1] + delta_ed_var[,1]
        }else{
            delta_ed_final_in <- delta_ed_var[,1]
        }
        return(delta_ed_final_in)
    }

###############################################################################
###############################################################################  
    return(list("cost_per_student_f" = cost_per_student_f,
                "delta_ed_final_f" = delta_ed_final_f))
}
invisible( list2env(chunk_edcosts(),.GlobalEnv) )

##### Execute values of the functions above when needed for the text:
cost_per_student_in <- cost_per_student_f()
delta_ed_final_in <- delta_ed_final_f(include_ext_var = FALSE)
```

**Note:** need to understand better the date of each component (of the model, not only this section).

##### 6 - $\left( S_{2}Q(S_{2}) - S_{1}Q(S_{1}) \right)$

###### 6.1 - $S_{1}Q(S_{1}) = 0$
There is no subsidy for deworming under the status quo.   


###### 6.2 - $S_{2}$: complete subsidy to per capita costs of deworming.

With complete subsidy, $S_2$ represents the total direct costs of deworming in USD. Calculated as follows

\begin{equation}
S_{2} = \frac{\text{Cost per person per year (KSH)}	}{ex}\times \text{Additional years of treatment} \\
\end{equation}

###### 6.3 - $Q_{2}$
The take-up with full subsidy ($Q_2$) comes from a previous study (Miguel and Kremer 2007) and takes the value of `r q_full_so`.

```{r unit_costs2}
# - inputs:
# - outputs:
chunk_unit_costs2 <- function(){
###############################################################################
###############################################################################  

    s2_f <- function(unit_cost_local_var = unit_cost_local_so,
                     ex_rate_var = ex_rate_so, years_of_treat_var = years_of_treat_so) {
      ( unit_cost_local_var / ex_rate_var ) * years_of_treat_var
    }

###############################################################################
###############################################################################  
    return(list("s2_f" = s2_f) )
}
invisible( list2env(chunk_unit_costs2(),.GlobalEnv) )
##### Execute values of the functions above when needed for the text:


```




### Benefits ("$B$")  

Bair et al. (2016) compute benefits like this:

\begin{equation}
B =   \sum_{t=0}^{50}\left(  \frac{1}{1 + r}\right)^{t} E_{t}
\label{eq:5}
\tag{5}
\end{equation}

**Note:** The original equation separates effects by gender. But the final calculation (behind table 5 in paper) does not separate by gender.



Where:   

 - $r$: is the discount rate  
 - $w_t$: are the earnings in period $t$.   
 - $\lambda_{1}$: is the direct effects of deworming on earnings.  
 - $\lambda_{2}$: is the indirect effects of deworming on earnings.   
 - $p$: saturation, measures the fraction of the population that is effectively usign the treatment.  
 - $R$: coverage, defined as the fraction, among all neighboring schools (within 6 km), that belongs to the treatment group.  


```{r benefits}
# - inputs: nothing
# - outputs: function that computes the country weights used in the final costs
chunk_benefits <- function(){
###############################################################################
###############################################################################  

    pv_benef_f <- function(earnings_var = earnings_in, interest_r_var = interest_in,
                    periods_var = periods_so) {
      index_t <- 0:periods_var
      res1 <- sum( ( 1 / (1 + interest_r_var) )^index_t * earnings_var )
      return(res1)   
    }

###############################################################################
###############################################################################  
    return(list("pv_benef_f" = pv_benef_f))
}
invisible( list2env(chunk_benefits(),.GlobalEnv) )
```

#### "$r$"  

The real interest rate $r$ is obtained from the interest rate on goverment bonds (`r round(gov_bonds_so, 3)`) minus the inflation rate (`r inflation_so`).

```{r interest-rate}
# - inputs: gov_bonds_so, inflation_so
# - outputs: interest_in
chunk_interest <- function(){
###############################################################################
###############################################################################  

    interest_f <- function(gov_bonds_var = gov_bonds_so , inflation_var = inflation_so) {  
        interest_in = gov_bonds_var - inflation_var
        return(list("interest_in" = interest_in))
    }

###############################################################################
###############################################################################  
    return(list("interest_f" = interest_f))
}

invisible( list2env(chunk_interest(),.GlobalEnv) )
interest <- as.numeric( interest_f() )
```


The resulting value is a $r$ = `r paste(round(100 * interest,2), "%", sep="")`


#### Earnings
Where $E_t$ represents earnings in period $t$. That can be computed in two ways.


##### numer one

\begin{equation}
E_t = w_{t}\left( \lambda_{1} + \frac{p \lambda_{2}}{R} \right)
\end{equation}

```{r earnings1}
# - inputs: gov_bonds_so, inflation_so
# - outputs: interest_in
earnings1_f <- function(){
###############################################################################
###############################################################################  

    earnings1 <- function(wage_var = wage_in,
                          lambda1_var = lambda1_so,
                          lambda2_var = lambda2_so,
                          saturation_var = saturation, coverage_var) {  
        res1 <- wage_var * ( lambda1_var + saturation_var * lambda2_var / coverage_var )
        return(res1)
    }

###############################################################################
###############################################################################  
    return(list("earnings1" = earnings1))
}

invisible( list2env(earnings1_f(),.GlobalEnv) )
```

###### "$w_{t}$"

The wages/earnings are determined by:  

\begin{equation}
w_t =  \text{#weeks} \times w_0 (1 + g)^{Xp}(1 + \hat{\beta_1} Xp + \hat{\beta_2} Xp^2) \quad \text{for } t=10, \dots, 50
\end{equation}

individuals in the data are assumed to enter the labor force 10 years after the (data) present day ($w_t = 0$ for $t<10$). Wage at time $t$ is the weekly starting wage in USD ($w_0$) that has a base growth rate equal to the per capita GDP growth ($g$) applied to however many years of work ($Xp$). In addition to this growth, the salaries are adjusted to represent a (concave) wage life cycle profile ($1 + \hat{\beta_1} Xp + \hat{\beta_2} Xp^2$).

###### "$w_0$"

\begin{equation}
w_t =  \text{#weeks} \times \blue{w_0} (1 + g)^{Xp}(1 + \hat{\beta_1} Xp + \hat{\beta_2} Xp^2)
\end{equation}

\begin{equation}
w_0 = \frac{1}{ex} \sum_{l \in \{ag, ww, se\}}w_{l}\alpha_{l} \\ \quad \text{with: } \alpha_{l}= \frac{ h_{l}}{h_{ag} + h_{ww} + h_{se}}  
\end{equation}

The initial wage in dollars ($w_{0}$) is a weighted average of wages for control group in agriculture, working wage, and self-employed sectors ($ag, ww, se$). The weights correspond to the average number of hours in each sector ($h_l$) relative to the sum of the average number of hours in each sector.

The wage in agriculture comes from research (Suri, 2011), the working wage comes from the data and its defined as  hourly wage for the control group for those who reported more than 10 hrs of work per week. The self-employed wage ($w_{se}$) was constructed as follows:

\begin{equation}
w_{se} =  \frac{ \text{Monthly self-employed profits} }{4.5 \times E[h_{se}|h_{se}>0] }
\end{equation}

Where both parameters (Monthly self-employed profits and self-employed hours for the control group, conditional on hrs >0 - $E[h_{se}|h_{se}>0]$ -) come from the data (ww paper).  The measure of hours in self employment used to compute wages is ($E[h_{se}|h_{se}>0]$) is different from the one is to compute the weights $\alpha_l$ above. The first one captures hours of work among those actively employed in the self-employed sector, and the second one captures the average hours of work in self-employed among all the population of workin age in the sample (hence capturing the relative inportance of the self employed sector in the economy)


```{r wage_t}
#inputs: wages (wage_ag_so, wage_ww_so) self employed income (profits_se_so,
#  hours_se_cond_so) hours of work (hours_ag_so, hours_ww_so, hours_se_so),
#  exchange rate (ex_rate_so), timing vars (periods_so, time_to_jm_so),
#  growth rate (growth_rate_so), mincer coef (coef_exp_so[1], coef_exp_so[2])
#
#outputs: Starting wages: value (wage_0_mo) and function (wage_0_mo_f), Wage trayectory:
#  value (wage_t_mo) and function (wage_t_mo_f).
wages_f <- function(){
################################################################################
################################################################################  
    #close to value from spreadsheet (Assumps&Panel A Calcs!B137 = 0.1481084),
    #but I suspect diff due to computational precision

    wage_0_mo_f <- function(wage_ag_var, wage_ww_var, profits_se_var, hours_se_cond_var,
                            hours_ag_var, hours_ww_var, hours_se_var, ex_rate_var) {
        experience_aux <- 0:periods_so - time_to_jm_so
        wage_se <- profits_se_var / (4.5 * hours_se_cond_var)
        wage_ls <- c(wage_ag_var, wage_ww_var, wage_se)
        alpha_ls <- c(hours_ag_var, hours_ww_var, hours_se_var) / sum( c(hours_ag_var, hours_ww_var, hours_se_var) )
        res1 <- 1/ex_rate_var * sum( wage_ls * alpha_ls )
        return(res1)
    }

    wage_t_mo_f <- function(wage_0_var,
                       growth_rate_var,
                       coef_exp1_var,
                       coef_exp2_var) {
        experience_aux <- 0:periods_so - time_to_jm_so
        res1 <- 52 * wage_0_var *( ( 1 + growth_rate_var )^experience_aux ) *
          ( 1 + coef_exp1_var * experience_aux + coef_exp2_var * experience_aux^2 ) *
          ifelse(0:periods_so >= time_to_jm_so, 1, 0)
        return(res1)
    }

    wage_0_mo <- wage_0_mo_f(wage_ag_var = wage_ag_so,  
                         wage_ww_var = wage_ww_so,
                         profits_se_var = profits_se_so,
                         hours_se_cond_var = hours_se_cond_so,  
                         hours_ag_var = hours_ag_so,
                         hours_ww_var = hours_ww_so,
                         hours_se_var = hours_se_so,
                         ex_rate_var = ex_rate_so)  

    #close to value from spreadsheet (Calcs-Table 5!N21.. = 7.701634678),
    #but I suspect diff due to computational precision
    wage_t_mo <- wage_t_mo_f(wage_0_var = wage_0_mo,
                       growth_rate_var = growth_rate_so,
                       coef_exp1_var = coef_exp_so[1],
                       coef_exp2_var = coef_exp_so[2])

################################################################################
################################################################################
    return(list("wage_0_mo_f" = wage_0_mo_f, "wage_0_mo" = wage_0_mo,
                "wage_t_mo_f" = wage_t_mo_f, "wage_t_mo" = wage_t_mo))
}

invisible( list2env(wages_f(),.GlobalEnv) )
```


##### Number two

\begin{equation}
E_t = \Delta Y_t = I(10 \leq t < 15) \lambda_{1}^{k1} + I(15 \leq t < 20) \lambda_{1}^{k2} + I(20 \leq t < 25) \lambda_{1}^{k3}  
\end{equation}

Where     

 - $I(10 \leq t < 15)$ represents ...  
 - $\lambda_{1}^{k1}$ represents ...  





```{r delta-earnings, eval=TRUE}
# - inputs:
# - outputs:
chunk_new_earnings <- function(){
###############################################################################
###############################################################################  

    delta_earnings_f <- function(t_var = 1,
                               lambda1k1_var = lambda1_new_so[1],
                               lambda1k2_var = lambda1_new_so[2],
                               lambda1k3_var = lambda1_new_so[3]) {
        1*(10 <= t_var & t_var < 15) * lambda1k1_var +
        1*(15 <= t_var & t_var < 20) * lambda1k2_var +
        1*(20 <= t_var) * lambda1k3_var
    }

###############################################################################
###############################################################################             
    return(list("delta_earnings_f" = delta_earnings_f))
}

invisible( list2env(chunk_new_earnings(),.GlobalEnv) )

```


#### "$\lambda_{1}$"  and  "$\lambda_{2}$"

$\lambda_{1,\gamma}$ represents the estimated impact of deworming on hours of work for men a women. This two parameter are combined with a simple mean:

\begin{equation}
\lambda_{1} = \frac{1}{2} \lambda_{1,male} + \frac{1}{2} \lambda_{1,female} \\
\lambda_{1,\gamma} = \alpha \lambda^{eff}_{1,\gamma} + (1 -  \alpha) \times 0
\end{equation}

Where:      

 - $\alpha$: represents the incidence of the condition.  
 - $\lambda_{1}^{eff}$: represents the effect of deworming over those affected with the condition.  
 - $\lambda_{2}^{eff}$: ?. **[discuss with Ted/Michael]**

**WARNING: the next paragraph has a bunch of hard coded numbers that need to be reviewed and coded up**   

In the original evaluation, $\alpha = `r alpha_0_so`$, hence $\lambda_{1}^{eff} = 1.75/0.92 = 1.94$. The value of $\lambda^{r}_{1}$ for each region $r$ will depend on that region's $\alpha^{r}$.  

Its components come from the W\@W paper.

$\lambda_{2,\gamma}$ the estimated externality effect (EXPLAIN) and comes from research (W\@W). Note that this parameter in not estimated by gender, so we repeat its value two times.

```{r lambdas}
# - inputs:
# - outputs:
lambdas_in_f <- function(){
###############################################################################
###############################################################################    

    lambda1_in_f <- function(lambda1_var = lambda1_so) {
        rep(0.5 * lambda1_var[1] + 0.5 *lambda1_var[2], 2)
    }

    lambda_r_f <- function(lambda1_var = lambda1_in_f(), alpha_0_var = alpha_0_so,
                         alpha_r_var=alpha_r_so){
        lambda1_eff_temp <- lambda1_var / alpha_0_var
        return( lambda1_eff_temp * alpha_r_var )
    }  

    lambda2_in_f <- function(lambda2_var = lambda2_so){
        rep(lambda2_var, 2)
    }

##############################################################################
###############################################################################  
    return(list("lambda_r_f" = lambda_r_f,     
                "lambda1_in_f" = lambda1_in_f,
                "lambda2_in_f" = lambda2_in_f ) )
}
invisible( list2env(lambdas_in_f(),.GlobalEnv) )

##### Execute values of the functions above when needed for the text:
lambda1_in <- lambda1_in_f()
lambda1_r_in <- lambda_r_f()
lambda2_in <- lambda2_in_f()
```


#### $R$ and $p$


The coverage, $R$, is defined as the fraction, among all neighboring schools (within 6 km), that belongs to the treatment group (last paragraph of page 9(1645) of paper). As the treatment was appplied to approximatedly two thirds of the population, $R$ is set to: $R  = `r round(coverage_so, 2)`$.  

The saturation of the intervention, $p$, measures the fraction of the population that is effectively usign the treatment and is defined as:  

\begin{equation}
p = R \times Q(full)  + (1 - R) \times Q(0)
\end{equation}

For this (or similar?) setting Miguel and Kremer 2007 [add page, table, col, row] estimate that there is almost no take-up without subsidy, hence $Q(0)$ is assinged the value of `r q_zero_so`. The same article [add page, table, col, row] estimates that take-up with full subsidy is $Q(full) = `r q_full_so`$.

```{r coverage-and-saturation}
# - inputs: coverage_so, q_full_so, q_zero_so
# - outputs: saturation_in
chunk_coverage <- function(){
###############################################################################
###############################################################################  

    saturation_in_f <- function(coverage_var = coverage_so, q_full_var = q_full_so,
                                q_zero_var = q_zero_so){
        saturation_in <- coverage_so * q_full_so + ( 1 - coverage_so ) * q_zero_so
        return(list("saturation_in" = saturation_in))
    }

###############################################################################
###############################################################################  
    return(list("saturation_in_f" = saturation_in_f))    # Try to return only functions
}
invisible( list2env(chunk_coverage(),.GlobalEnv) )

##### Execute values of the functions above when needed for the text:

```


# Main results

```{r all-steps}

# NPV, CEA, RCEA
# ├──── pv_benef_f
# │      ├──── earnings1
# │      |      ├──── wage_t
# │      |      |      └──── wage_0
# |      |      ├──── lambda1
# │      |      |      └────lambda1_r
# |      |      ├──── lambda2
# │      |      └──── saturation
# │      ├──── earnings2 RENAME
# │      |      └──── delta_earnings_f
# │      |             └────lambda_r_f
# │      └──── interest_f
# └──── cost1_f
# │      └──── costs1_ratios_in_f
# |             ├──── costs1_costs_f
# │             └──── costs1_counts_f
# └──── cost2_f = 11.63818
#        ├──── delta_ed_final_f
#        ├──── interest_f
#        ├──── s2_f
#        └──── cost_per_student_f


#unit test
unit_test <- function(to_test_var, original_var){
    if (length(to_test_var) > 1) {
        fails_test <- ( abs(sd(to_test_var) - original_var)>0.0001 )
        text_val <- sd(to_test_var)
    } else {
        fails_test <- ( abs(to_test_var - original_var)>0.0001 )
        text_val <- to_test_var
    }
    if (fails_test) {
        print(paste("Output has change at", deparse(substitute(to_test_var) ), " to ", text_val) )
    }
}


# Write only functions here. And make all arguments explicit
#--------------- Inputs for wage_t ---------------------------------------------
# Make explicit non-function inputs:
wage_0_in <- wage_0_mo_f(wage_ag_var = wage_ag_so, wage_ww_var = wage_ww_so,
            profits_se_var = profits_se_so, hours_se_cond_var = hours_se_cond_so,  
            hours_ag_var = hours_ag_so, hours_ww_var = hours_ww_so,
            hours_se_var = hours_se_so, ex_rate_var = ex_rate_so)
unit_test(wage_0_in, 0.1481084)

#--------------- Inputs for earnings1 -------------------------------------------
# Make explicit non-function inputs:
wage_t_in <- wage_t_mo_f(wage_0_var = wage_0_in, growth_rate_var = growth_rate_so,
            coef_exp1_var = coef_exp_so[1], coef_exp2_var = coef_exp_so[2])

lambda1_in <- lambda1_in_f(lambda1_var = lambda1_so)
lambda1_r_in <- lambda_r_f(lambda1_var = lambda1_in, alpha_0_var = alpha_0_so,
                           alpha_r_var = alpha_r_so)
lambda2_in <- lambda2_in_f(lambda2_var = lambda2_so)

saturation_in <- as.numeric(saturation_in_f(coverage_var = coverage_so, q_full_var = q_full_so,
                                 q_zero_var = q_zero_so) )
unit_test(wage_t_in, 4.572308)

#--------------- Inputs for earnings2 -------------------------------------------
lambda1_new_in <- lambda_r_f(lambda1_new_so, alpha_0_var = alpha_0_so,
                             alpha_r_var = alpha_r_so)

#--------------- Inputs for pv_benef_f -------------------------------------------
# Make explicit non-function inputs:
earnings_in_no_ext <- earnings1(wage_var = wage_t_in, lambda1_var = lambda1_in[1],
            lambda2_var = 0, saturation_var = saturation_in,
            coverage_var = coverage_so)
earnings_in_yes_ext <- earnings1(wage_var = wage_t_in, lambda1_var = lambda1_in[1],
            lambda2_var = lambda2_in[1], saturation_var = saturation_in,
            coverage_var = coverage_so)

# earnings2
earnings_in_no_ext_new <- delta_earnings_f(t_var = 0:50,
                                         lambda1k1_var = lambda1_new_in[1],
                                         lambda1k2_var = lambda1_new_in[2],
                                         lambda1k3_var = lambda1_new_in[3])
# ADD UNIT TEST

interest_in <- as.numeric( interest_f(gov_bonds_var = gov_bonds_so, inflation_var = inflation_so) )

unit_test(earnings_in_no_ext, 7.978677)
unit_test(earnings_in_yes_ext, 42.95683)
unit_test(interest_in, 0.0985)

#--------------- Inputs for costs1 ---------------------------------------------
# Make explicit non-function inputs:

costs1_costs_in <- costs1_costs_f(df_costs_var = df_costs_so,
                                  df_costs_cw_var = df_costs_cw_so,
                                  staff_time_var = staff_time_so)$cost_data

costs1_counts_in <- costs1_counts_f(df_counts_var = df_counts_so,
                                    df_costs_cw_var = df_costs_cw_so)$counts_data

costs1_country <-  costs1_ratios_in_f(counts_var = costs1_counts_in, costs_var =  costs1_costs_in)

unit_test(unlist(costs1_country$ratios_data$costs_by_country),  6880801.84046596)

#--------------- Inputs for costs2 ---------------------------------------------
# Make explicit non-function inputs:
delta_ed_final_in <- delta_ed_final_f(include_ext_var = FALSE,
                                      delta_ed_var = delta_ed_so,
                                      delta_ed_ext_var = delta_ed_ext_so)
unit_test(delta_ed_final_in, 0.01134819)
delta_ed_final_in_x <- delta_ed_final_f(include_ext_var = TRUE,
                                      delta_ed_var = delta_ed_so,
                                      delta_ed_ext_var = delta_ed_ext_so)
unit_test(delta_ed_final_in_x,  0.05911765)
interest_in <- as.numeric( interest_f(gov_bonds_var = gov_bonds_so, inflation_var = inflation_so) )
unit_test(interest_in, 0.0985)
cost_per_student_in <-  cost_per_student_f(teach_sal_var = teach_sal_so,
                                          teach_ben_var = teach_ben_so,
                                          n_students_var = n_students_so)
unit_test(cost_per_student_in,  116.8549)
s2_in <- s2_f(unit_cost_local_var = unit_cost_local_so,
              ex_rate_var = ex_rate_so, years_of_treat_var = years_of_treat_so)
unit_test(s2_in, 1.237889)

#--------------- Inputs for NPV ------------------------------------------------
# Make explicit non-function inputs:
pv_benef_in <- pv_benef_f(earnings_var = earnings_in_no_ext * tax_so,
                        interest_r_var = interest_in, periods_var = periods_so)
unit_test(pv_benef_in, 11.02849)

pv_benef_in_x <- pv_benef_f(earnings_var = earnings_in_yes_ext * tax_so,
                        interest_r_var = interest_in, periods_var = periods_so)
unit_test(pv_benef_in_x, 59.37686)

pv_benef_in_new <- pv_benef_f(earnings_var = earnings_in_no_ext_new * tax_so,
                        interest_r_var = interest_in, periods_var = periods_so)
# ADD UNIT TEST
cost1_in <- costs1_f(country_w_var = costs1_country$ratios_data$country_w,
                     country_cost_var = costs1_country$ratios_data$per_cap)
unit_test(cost1_in,  0.08480686)

costs2_in <- cost2_f(periods_var = periods_so, delta_ed_var = delta_ed_final_in,
           interest_r_var = interest_in, cost_of_schooling_var = cost_per_student_in,
           s1_var = 0, q1_var = 0, s2_var = s2_in, q2_var = q_full_so)
unit_test(costs2_in, 11.63818)

costs2_in_x <- cost2_f(periods_var = periods_so, delta_ed_var = delta_ed_final_in_x,
           interest_r_var = interest_in, cost_of_schooling_var = cost_per_student_in,
           s1_var = 0, q1_var = 0, s2_var = s2_in, q2_var = q_full_so)
unit_test(costs2_in_x,  25.05821)


```


```{r main-results}
#no externality NPV
res_npv_no_ext_pe <- NPV_pe(benefits_var = pv_benef_in, costs_var = costs2_in)
unit_test(res_npv_no_ext_pe, -0.6096942)
#yes externality NPV
res_npv_yes_ext_pe <- NPV_pe(benefits_var = pv_benef_in_x, costs_var = costs2_in_x)
unit_test(res_npv_yes_ext_pe, 34.31866)

#no externality NPV using EAs costs
res_npv_no_ext_ea <- NPV_pe(benefits_var = pv_benef_in, costs_var = cost1_in)
unit_test(res_npv_no_ext_ea, 10.9436791201805)
#yes externality NPV using EAs costs
res_npv_yes_ext_ea <- NPV_pe(benefits_var = pv_benef_in_x, costs_var = cost1_in)
unit_test(res_npv_yes_ext_ea, 59.2920560586455)


#KLPS2019
res_npv_no_ext_klps <- NPV_pe(benefits_var = pv_benef_in_new, costs_var = costs2_in)
unit_test(res_npv_no_ext_klps, 47.6017891133612)

#CEA for EA
cea_no_ext_ea <- CEA_pe(benefits_var = pv_benef_in, costs_var = cost1_in, fudging_var = 0)
unit_test(cea_no_ext_ea, 130.042378933876)

rcea_no_ext_ea <- RCEA_pe( CEA_var = CEA_pe(benefits_var = pv_benef_in, costs_var = cost1_in, fudging_var = 0),
         CEA_cash_var = 744)
unit_test(rcea_no_ext_ea, 0.174788143728328)

```


- **NPV without externalities in Baird et al, 2016 ($\lambda_2 = 0$):** `r round(res_npv_no_ext_pe,4)`    

- **NPV with externalities in Baird et al, 2016 ($\lambda_2 = `r round(lambda2_so,2)`$ ):** `r round(res_npv_yes_ext_pe,4)`

- **NPV without externalities in EA 2019 ($\lambda_2 = 0$):** `r round(res_npv_no_ext_ea,4)`    

- **NPV with externalities in EA 2019 ($\lambda_2 = `r round(lambda2_so,2)`$ ):** `r round(res_npv_yes_ext_ea,4)`

- **NPV without externalities in KLPS 2019:** `r round(res_npv_no_ext_klps,4)`    

- **CEA without externalities in EA:** `r round(cea_no_ext_ea,4)`    

- **RCEA without externalities in EA (relative to cash):** `r round(rcea_no_ext_ea,4)`    


# Montecarlo simulations  

```{r, eval=TRUE}  

# Remove everything except the chunk functions
#rm(list = ls()[!(ls() %in% ls(pattern = "call_params_f()"))])
#invisible( list2env(call_params_f(), .GlobalEnv) )
# add chunk functions

# Draws
set.seed(142857)
nsims <- 1e2
include_ext_mo <- TRUE
start_time <- Sys.time()

#Defaoult dist: normal, default sd: 0.1* mean
## Data
gov_bonds_sim <-        rnorm(n = nsims, mean = gov_bonds_so, sd = 0.1 * gov_bonds_so)
inflation_sim <-        rnorm(nsims, inflation_so, 0.1 * inflation_so)

wage_ag_sim <-          rnorm(nsims, wage_ag_so, 0.1 * wage_ag_so)
wage_ww_sim <-          rnorm(nsims, wage_ww_so, 0.1 * wage_ww_so)
profits_se_sim <-       rnorm(nsims, profits_se_so, 0.1 * profits_se_so)
hours_se_cond_sim <-    rnorm(nsims, hours_se_cond_so, 0.1 * hours_se_cond_so)
hours_ag_sim <-         rnorm(nsims, hours_ag_so, 0.1 * hours_ag_so)
hours_ww_sim <-         rnorm(nsims, hours_ww_so, 0.1 * hours_ww_so)
hours_se_sim <-         rnorm(nsims, hours_se_so, 0.1 * hours_se_so)
coverage_sim <-         rnorm(nsims, coverage_so, 0.1 * coverage_so)
growth_rate_sim <-      rnorm(nsims, growth_rate_so, 0.1 * growth_rate_so)

ex_rate_sim <-          rnorm(nsims, ex_rate_so, 0.1 * ex_rate_so)
tax_sim <-              rnorm(nsims, tax_so, 0.1 * tax_so)

unit_cost_local_sim <-  rnorm(nsims, unit_cost_local_so, 0.1 * unit_cost_local_so)
years_of_treat_sim <-   rnorm(nsims, years_of_treat_so, 0.1 * years_of_treat_so)

## Research
aux1 <- 0.1 * c(lambda1_so[1], 0.01)
# Each list is a pair mean, sd.
aux2 <- lapply(1:2,function(x) c(lambda1_so[x], aux1[x] ) )
lambda1_sim <- sapply(aux2, function(x)  rnorm(nsims, mean = x[1], sd = x[2]) )
lambda2_sim <-          rnorm(nsims, lambda2_so,  0.1 * lambda2_so)
# New lambdas here
aux3 <- lapply(1:3,function(x) c(lambda1_new_so[x], lambda1_new_sd_so[x] ) )
lambda1_new_sim <- sapply(aux3, function(x)  rnorm(nsims, mean = x[1], sd = x[2]) )

q_full_sim <-           rnorm(nsims, q_full_so, 0.1 * q_full_so)
q_zero_sim <-           rnorm(nsims, q_zero_so, 0.1 * q_zero_so)

# Prevalence here TO DO: draw from a beta instead of "truncated" normal
alpha_0_sim <- rnorm(nsims, alpha_0_so, 0.1 * alpha_0_so)
alpha_0_sim <- ifelse(alpha_0_sim > 1, yes = 1, ifelse(alpha_0_sim < 0, 0, alpha_0_sim) )
alpha_r_sim <- rnorm(nsims, alpha_r_so, 0.1 * alpha_r_so)
alpha_r_sim <- ifelse(alpha_r_sim > 1, yes = 1, ifelse(alpha_r_sim < 0, 0, alpha_r_sim) )

## Guess work
periods_val <- 50           #Total number of periods to forecast wages
time_to_jm_val <- 10        #Time from intial period until individual join the labor force
aux2 <- lapply(1:2, function(x) c(coef_exp_so[x],c(0.001 , 0.001)[x]) )
coef_exp_sim <- sapply(aux2, function(x)  rnorm(nsims, mean = x[1], sd = x[2]) )     
teach_sal_sim <-    rnorm(nsims, teach_sal_so, 0.1 * teach_sal_so)
teach_ben_sim <-    rnorm(nsims, teach_ben_so, 0.1 * teach_ben_so)
n_students_sim <-   rnorm(nsims, n_students_so, 0.1 * n_students_so)
staff_time_sim <- rnorm(nsims, staff_time_so, 0.1 * staff_time_so)      

delta_ed_sim <- sapply(delta_ed_so[,1], function(x) rnorm(nsims, mean =
                                                                  x * 1,
                                                                  sd = 1 * sd(delta_ed_so[,1]) ) )
colnames(delta_ed_sim) <- 1999:2007

delta_ed_ext_sim <- sapply(delta_ed_ext_so[,1], function(x)  rnorm(nsims, mean =
                                                                            x * 1,
                                                                          sd = 1 * sd(delta_ed_ext_so[,1])))
colnames(delta_ed_ext_sim) <- 1999:2007

######
res_npv_no_ext_sim      <- rep(NA, nsims)
res_npv_yes_ext_sim     <- rep(NA, nsims)
res_npv_no_ext_ea_sim   <- rep(NA, nsims)
res_npv_yes_ext_ea_sim  <- rep(NA, nsims)
res_npv_no_ext_klps_sim <- rep(NA, nsims)
cea_no_ext_ea_sim       <- rep(NA, nsims)
rcea_no_ext_ea_sim      <- rep(NA, nsims)

#Run simulations
for (i in 1:nsims) {
    # Compute inputs
    # Write only functions here. And make all arguments explicit
    #--------------- Inputs for wage_t ---------------------------------------------
    # Make explicit non-function inputs:
    wage_0_in <- wage_0_mo_f(wage_ag_var = wage_ag_sim[i], wage_ww_var = wage_ww_sim[i],
                profits_se_var = profits_se_sim[i], hours_se_cond_var = hours_se_cond_sim[i],  
                hours_ag_var = hours_ag_sim[i], hours_ww_var = hours_ww_sim[i],
                hours_se_var = hours_se_sim[i], ex_rate_var = ex_rate_sim[i])

    #--------------- Inputs for earnings -------------------------------------------
    # Make explicit non-function inputs:
    wage_t_in <- wage_t_mo_f(wage_0_var = wage_0_in, growth_rate_var = growth_rate_sim[i],
                coef_exp1_var = coef_exp_sim[i,1], coef_exp2_var = coef_exp_sim[i,2])
    #lambda1_in <- lambda1_in_f(lambda1_var = lambda1_sim[i,])
    lambda1_in <- lambda_r_f(lambda1_var = lambda1_in_f(lambda1_var = lambda1_sim[i,]),
                             alpha_0_var = alpha_0_sim[i], alpha_r_var = alpha_r_sim[i])

    lambda1_new_sim[i,] <- lambda_r_f(lambda1_var = lambda1_new_sim[i,],
                                      alpha_0_var = alpha_0_sim[i],
                                      alpha_r_var = alpha_r_sim[i])

    lambda2_in <- lambda2_in_f(lambda2_var = lambda2_sim[i])

    saturation_in <- as.numeric(saturation_in_f(coverage_var = coverage_sim[i],
                                                q_full_var = q_full_sim[i],
                                                q_zero_var = q_zero_sim[i]) )
    #--------------- Inputs for pv_benef_f -------------------------------------------
    # Make explicit non-function inputs:
    earnings_in_no_ext <- earnings1(wage_var = wage_t_in, lambda1_var = lambda1_in[1],
                lambda2_var = 0, saturation_var = saturation_in,
                coverage_var = coverage_sim[i])
    earnings_in_yes_ext <- earnings1(wage_var = wage_t_in, lambda1_var = lambda1_in[1],
                lambda2_var = lambda2_in[1], saturation_var = saturation_in,
                coverage_var = coverage_sim[i])
    interest_in <- as.numeric( interest_f(gov_bonds_var = gov_bonds_sim[i], inflation_var = inflation_sim[i]) )

    #--------------- Inputs for costs1 ---------------------------------------------
    # Make explicit non-function inputs:
    costs1_costs_in <- costs1_costs_f(df_costs_var = df_costs_so,
                                      df_costs_cw_var = df_costs_cw_so,
                                      staff_time_var = staff_time_sim[i])$cost_data

    # this line does not changes across sims (not removing it for consistency)
    costs1_counts_in <- costs1_counts_f(df_counts_var = df_counts_so,
                                        df_costs_cw_var = df_costs_cw_so)$counts_data

    costs1_counts_sim <- costs1_counts_in %>%
      mutate("total" = rnorm(n = 1, mean = total, sd = 0.1 * total))

    costs1_costs_sim <- costs1_costs_in %>% group_by(Country) %>%
      mutate("costs_by_country" = rnorm(n = 1, mean = costs_by_country, sd = 0.1 * costs_by_country))

    costs1_country_sim <-  costs1_ratios_in_f(counts_var = costs1_counts_sim,
                                              costs_var =  costs1_costs_sim)
    #--------------- Inputs for costs2 ---------------------------------------------
    # Make explicit non-function inputs:
    delta_ed_final_in <- delta_ed_final_f(include_ext_var = FALSE,
                                          delta_ed_var = cbind(delta_ed_sim[i,], 1999:2007) ,
                                          delta_ed_ext_var = cbind(delta_ed_ext_sim[i,], 1999:2007) )
    delta_ed_final_in_x <- delta_ed_final_f(include_ext_var = TRUE,
                                          delta_ed_var = cbind(delta_ed_sim[i,], 1999:2007),
                                          delta_ed_ext_var = cbind(delta_ed_ext_sim[i,], 1999:2007) )
    interest_in <- as.numeric( interest_f(gov_bonds_var = gov_bonds_sim[i], inflation_var = inflation_sim[i]) )
    cost_per_student_in <- cost_per_student_f(teach_sal_var = teach_sal_sim[i],
                                              teach_ben_var = teach_ben_sim[i],
                                              n_students_var = n_students_sim[i])
    s2_in <- s2_f(unit_cost_local_var = unit_cost_local_sim[i],
                  ex_rate_var = ex_rate_sim[i], years_of_treat_var = years_of_treat_sim[i])
    #--------------- Inputs for NPV ------------------------------------------------
    # Make explicit non-function inputs:
    pv_benef_in <- pv_benef_f(earnings_var = earnings_in_no_ext * tax_sim[i],
                            interest_r_var = interest_in, periods_var = periods_so)

    pv_benef_in_x <- pv_benef_f(earnings_var = earnings_in_yes_ext * tax_sim[i],
                            interest_r_var = interest_in, periods_var = periods_so)

    cost1_in <- costs1_f(country_w_var = costs1_country_sim$ratios_data$country_w,
                     country_cost_var = costs1_country_sim$ratios_data$per_cap)

    costs2_in <- cost2_f(periods_var = periods_so, delta_ed_var = delta_ed_final_in,
               interest_r_var = interest_in, cost_of_schooling_var = cost_per_student_in,
               s1_var = 0, q1_var = 0, s2_var = s2_in, q2_var = q_full_sim[i])

    costs2_in_x <- cost2_f(periods_var = periods_so, delta_ed_var = delta_ed_final_in_x,
               interest_r_var = interest_in, cost_of_schooling_var = cost_per_student_in,
               s1_var = 0, q1_var = 0, s2_var = s2_in, q2_var = q_full_sim[i])

    # HERE ARE NOOR's results LOOK HERE
    earnings_in_no_ext_new <- delta_earnings_f(t_var = 0:50, lambda1k1_var = lambda1_new_sim[i,1],
                                             lambda1k2_var = lambda1_new_sim[i,2],
                                             lambda1k3_var = lambda1_new_sim[i,3])
    pv_benef_in_new <- pv_benef_f(earnings_var = earnings_in_no_ext_new * tax_sim[i],
                            interest_r_var = interest_in, periods_var = periods_so)


    # Compute policy estimate

    #no externality NPV
    res_npv_no_ext_sim[i] <- NPV_pe(benefits_var = pv_benef_in, costs_var = costs2_in)
    #yes externality NPV
    res_npv_yes_ext_sim[i] <- NPV_pe(benefits_var = pv_benef_in_x, costs_var = costs2_in_x)

    #no externality NPV using EAs costs
    res_npv_no_ext_ea_sim[i] <- NPV_pe(benefits_var = pv_benef_in, costs_var = cost1_in)
    #yes externality NPV using EAs costs
    res_npv_yes_ext_ea_sim[i] <- NPV_pe(benefits_var = pv_benef_in_x, costs_var = cost1_in)


    #KLPS2019
    res_npv_no_ext_klps_sim[i] <- NPV_pe(benefits_var = pv_benef_in_new, costs_var = costs2_in)

    #CEA for EA
    cea_no_ext_ea_sim[i] <- CEA_pe(benefits_var = pv_benef_in, costs_var = cost1_in, fudging_var = 0)
    rcea_no_ext_ea_sim[i] <- RCEA_pe( CEA_var = CEA_pe(benefits_var = pv_benef_in, costs_var = cost1_in, fudging_var = 0),
             CEA_cash_var = 744)
}



# res_npv_no_ext_sim      
# res_npv_yes_ext_sim     
# res_npv_no_ext_ea_sim   
# res_npv_yes_ext_ea_sim  
# res_npv_no_ext_klps_sim
# cea_no_ext_ea_sim       
# rcea_no_ext_ea_sim      

total_time <- Sys.time() - start_time

policy_estimates <- c("res_npv_no_ext_sim",      
"res_npv_yes_ext_sim",     
"res_npv_no_ext_ea_sim",   
"res_npv_yes_ext_ea_sim",  
"res_npv_no_ext_klps_sim",
"cea_no_ext_ea_sim",       
"rcea_no_ext_ea_sim")


#all_res_X_sims <- sapply(policy_estimates, function(x) sd(get(x)))
all_res_100_sims <- c(5.36646868710248, 28.2102343146369, 4.63586120809905, 24.5140846283501, 55.8112046549348, 59.5320802053472, 0.0800162368351441)
all_res_1000_sims <- c(5.25786076568104, 27.1261933981327, 4.48110757970705, 23.9749990025187, 55.2977762949186, 55.9742004724951, 0.0752341404200203)
all_res_10000_sims <- c(5.1957276, 27.3153648, 4.4892395, 24.1257271, 56.1707073094458, 56.3005638, 0.0756728)

for ( i in 1:length(policy_estimates) ) {
  to_test <- get(policy_estimates[i])
  if (nsims == 1e4){
      unit_test(to_test, all_res_10000_sims[i])
  } else if (nsims == 1e3){
      unit_test(to_test, all_res_1000_sims[i])
  } else if(nsims == 1e2){
      unit_test(to_test, all_res_100_sims[i])
  }
}

npv_sim <- res_npv_yes_ext_sim     

npv_for_text <- paste("Median NPV:\n ", round(median(npv_sim), 2))
npv_for_text2 <- paste("SD NPV:\n ", round(sd(npv_sim), 2))

ggplot() +
  geom_density(aes(x = npv_sim,
                   alpha = 1/2), kernel = "gau") +
  geom_vline(xintercept = c(0, median(npv_sim)), col="blue") +
  coord_cartesian(xlim = 1.2 * c(min(c(-1, npv_sim) ),max(npv_sim))) +
  guides(alpha = "none", colour="none") +
  labs(y = NULL,
       x = "NPV" ,
       title = "Distribution of NPV of Fiscal Impacts of Deworming",
       subtitle = paste0("N = ", nsims, " simulations. Take: ",
                         round(total_time, 1)," ",attributes(total_time)$unit )  )+
  annotate("text", x = 1.5 * median(npv_sim), y = 0.012, label = npv_for_text, size = 6)+
  annotate("text", x = 1.5 * median(npv_sim), y = 0.004, label = npv_for_text2, size = 6)+
  theme(axis.ticks = element_blank(), axis.text.y = element_blank())

```

# Sensitivity Analysis  


[^1]: `F1 = GiveWell's estimates of Deworm the World's cost per child dewormed per year [2018]` Original [here](https://docs.google.com/spreadsheets/d/1jzS693Y-ZAIloQejlzSc3e3t7iPHyor1qt7HBjSVXhQ/edit#gid=509033857), editable version [here](https://docs.google.com/spreadsheets/d/1hmijmJBeCJAKI1dT8n5iOLAAxfzWrKYJM_KfouFYI2w/edit#gid=509033857)
`F2 = 2019 GiveWell Cost-effectiveness Analysis — Version 3`  
`F3 = 2018 Worm Intensity Workbook — Version 1` Sheets are named the first time and numbered thereafter.


[^2]: to account for several high-level activities Deworm the World does not include in its cost per treatment analyses, as they are not directly related to any particular program


[^3]: https://docs.google.com/document/d/1BkQLyLYQmy9O7FISge78PnWy9urMo0k31RwI5tOhJE4/edit
